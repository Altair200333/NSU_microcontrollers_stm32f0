#pragma once
#include "stm32f0xx.h"
#include "renderAPI.h"
#include <math.h>
//idle value = 145(5-7)
//min  value = 1455
static volatile uint32_t rawValue = 0;
int group = 2;

typedef struct{
uint32_t   s[3];
uint8_t      i;
uint8_t      ready;
}TSC_RESULT;

TSC_RESULT Result;
#define b1111 15
#define b11 3
#define b111 7
#define b101 5
#define b110 6
#define b11111111 255
void ResetSensors(TSC_RESULT *pResult){
uint8_t   i;

for(i=0;i<3; i++) pResult->s[i] = 0xFFFF;

pResult->i = 0;
pResult->ready=0;
}
void ReadSensors(TSC_RESULT *pResult){

ResetSensors(pResult); // ????????? ???? ?????????
TSC->IOGCSR &= ~b11111111; // ????????? ???? ?????
TSC->IOGCSR |= TSC_IOGCSR_G1E_Msk; // ????????? ?????? G1
TSC->IOCCR &= ~b1111; // ????????? ???? ??????? ??????
TSC->IOCCR |= TSC_IOCCR_G1_IO2_Msk; // ????????? ??????? ?????? ?????? = PA1
__enable_irq ();    // ???????? ?????????? ??????????
NVIC->ISER[0] |= (1 << TSC_IRQn); // ????????? ?????????? TSC
TSC->CR |=  (1 << TSC_CR_START_Pos); // ?????? ?????????
}

void TSC_IRQHandler(void)
{
	
    // 1. ????????????
    if (TSC -> ISR & TSC_ISR_MCEF) { // ????? ????? ??????
      TSC -> ICR |= (TSC_ICR_EOAIC | TSC_ICR_MCEIC);
      // ????? ???? ??????, ??? ????????? ??????
      Result.s[0] = Result.s[1] = Result.s[2] = 0;
      Result.i = 0;
      Result.ready = 1;
      // ??????? ??? ???-?? ...
      // ...
      return;
    }

    // 2. ??? ???????? ??????????
    TSC -> ICR |= (TSC_ICR_EOAIC); // ????? ?????
    switch (Result.i) {
    case 0: // ????????? ?????? PA1
      Result.s[0] = TSC -> IOGXCR[0]; // ?????????? ????????
      TSC -> IOCCR &= ~b1111; // ?????????? ???? ??????? ??????
      TSC -> IOCCR |= (1 << TSC_IOCCR_G1_IO3_Pos); // ????????? ?????????? (PA2)
      break;
    case 1: // ????????? ?????? PA2
      Result.s[1] = TSC -> IOGXCR[0]; // ?????????? ????????
      TSC -> IOCCR &= ~b1111; // ?????????? ???? ??????? ??????
      TSC -> IOCCR |= (1 << TSC_IOCCR_G1_IO4_Pos); // ????????? ?????????? (PA3)
      break;
    case 2: // ????????? ?????? PA3
      Result.s[2] = TSC -> IOGXCR[0]; // ?????????? ????????
      TSC -> IOCCR &= ~b1111; // ?????????? ???? ??????? ??????
      break;
    }
    Result.i++;
    if (Result.i < 3) {
      // ?????? ?????????? ??????
      TSC -> CR |= 1 << TSC_CR_START_Pos;
      Result.ready = 0;
    } else {
      Result.ready = 1;
    }
}



void lateTSCinit()
{
	TSC->IER |= TSC_IER_EOAIE; //enable end of acquisition interrupt
	
	NVIC_EnableIRQ(TSC_IRQn);//bind interruput
	
	TSC->CR |= TSC_CR_PGPSC_2 | TSC_CR_PGPSC_0 | TSC_CR_CTPH_0 | TSC_CR_CTPL_0 | TSC_CR_MCV_2 | TSC_CR_MCV_1 | TSC_CR_TSCE;//TSC_CR_PGPSC_2 | TSC_CR_PGPSC_0 | TSC_CR_CTPH_0 | TSC_CR_CTPL_0 | TSC_CR_MCV_2 | TSC_CR_MCV_1 | TSC_CR_TSCE;//pure magic lol
	TSC->CR |= TSC_CR_START;//(0x01 + 0x00C0 + 0x02); //enable TSC and start acquisition
	//TSC->CR |= TSC_CR_AM;

}
//GPIOA->AFR[0] |= 3 << (0) * 4;
//alt.func. number ^;pin.^;   ^ - always the same
void touch_init(void) 
{
	// 1. ?????? ???????????? ?? GPIOA
RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

// 2. ?????? ???????????? TSC
RCC->AHBENR |= RCC_AHBENR_TSCEN;

// 3. ??????? ????? PA0...PA3 ? ????? ?????????????? ??????? (MODERx[1:0] = 10)
GPIOA->MODER &= ~(GPIO_MODER_MODER0_Msk | GPIO_MODER_MODER1_Msk | GPIO_MODER_MODER2_Msk | GPIO_MODER_MODER3_Msk);
GPIOA->MODER |=  GPIO_MODER_MODER0_1 | GPIO_MODER_MODER1_1 | GPIO_MODER_MODER2_1 | GPIO_MODER_MODER3_1;

// 4. ????? ?????? ?????????????? ??????? ("AF3") (??????? st_stm32f042.pdf ???. 38/117 = Table 14. Alternate functions selected through GPIOA_AFR registers for port A)
// AFR[0] = "AFRL", AFR[1] = "AFRH"
// PAx: GPIOA->AFR[0]: AFSELx [3:0] = 0011 ("AF3" = TSC_Gy_IOx)
GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL0 | GPIO_AFRL_AFSEL1 | GPIO_AFRL_AFSEL2 | GPIO_AFRL_AFSEL3);
GPIOA->AFR[0] |= (b11 << GPIO_AFRL_AFSEL0_Pos) | (b11 << GPIO_AFRL_AFSEL1_Pos) | (b11 << GPIO_AFRL_AFSEL2_Pos) | (b11 << GPIO_AFRL_AFSEL3_Pos);

// 5. ????? ???? ??????: (?) ?????? = "open drain" (bit = 1), (?) ???????? = "push-pull" (bit = 0)
GPIOA->OTYPER |= (GPIO_OTYPER_OT_0); // OD
GPIOA->OTYPER &= ~(GPIO_OTYPER_OT_1 | GPIO_OTYPER_OT_2 | GPIO_OTYPER_OT_3); // PP

// 6. ????? ???????? ?????? ?????? ???? (LOW (bits = x0): 2 MHz?, MEDIUM (bits = 01): 25 MHz?, HIGH (bits = 11): 50 MHz?)
// ??????? RM0091: 158/1004
GPIOA->OSPEEDR |= (b11 << GPIO_OSPEEDR_OSPEEDR0_Pos) | (b11 << GPIO_OSPEEDR_OSPEEDR1_Pos) | (b11 << GPIO_OSPEEDR_OSPEEDR2_Pos) | (b11 << GPIO_OSPEEDR_OSPEEDR3_Pos);

// 7. ????? ????????: 00 (none) / 01 (pull-up) / 10 (pull-down) // 11 (reserved)
// ??????? RM0091: 158/1004
// PA0: GPIO->PUPDR: PUPDR0 [1:0] = 00 (??? ????????)
// PA1: GPIO->PUPDR: PUPDR1 [1:0] = 00 (??? ????????)
GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPDR0 | GPIO_PUPDR_PUPDR1 | GPIO_PUPDR_PUPDR2 | GPIO_PUPDR_PUPDR3);

// ????????? TSC ???????????

TSC->CR = (b111 << TSC_CR_CTPH_Pos)   // Charge transfer pulse high [3:0] = t_PGCLK * "?32"
      | (0 << TSC_CR_CTPL_Pos)         // Charge transfer pulse low [3:0] = t_PGCLK * "x1"
      | (0 << TSC_CR_SSD_Pos)            // Spread spectrum deviation [6:0] = "x1" * t_SSCLK
      | (0 << TSC_CR_SSE_Pos)            // Spread spectrum enable = 0: DISABLE / 1: ENABLE
      | (1 << TSC_CR_SSPSC_Pos)         // Spread spectrum prescaler = 0: f_HCLK / 1: 0.5 * f_HCLK
      | (b101 << TSC_CR_PGPSC_Pos)   // Pulse generator prescaler [2:0] (f_HCLK/1... f_HCLK/128), t_PGCLK = b101 = /32
      | (b110 << TSC_CR_MCV_Pos)      // Max count value [2:0] = datasheet RM0091 -> p.311/1004, b110 = 16383
      | (0 << TSC_CR_IODEF_Pos)         // I/O Default mode: 0: output push-pull LOW / 1: input floating
      | (0 << TSC_CR_SYNCPOL_Pos)      // Synchronization pin polarity
      | (0 << TSC_CR_AM_Pos)            // Acquisition mode: 0: Normal acquisition mode / 1: Synchronized acquisition mode
      | (0 << TSC_CR_START_Pos)         // Start a new acquisition: 0 (hard): Acquisition not started / 1 (soft): Start a new acquisition
      | (1 << TSC_CR_TSCE_Pos);         // Touch sensing controller enable: 0: disabled / 1: enabled
// ?? ???????: The following TSC control register configurations are forbidden:
// • bits PGPSC are set to "000" and bits CTPL are set to "0000"
// • bits PGPSC are set to "000" and bits CTPL are set to "0001"
// • bits PGPSC are set to "001" and bits CTPL are set to "0000"

TSC->IER = (1 << TSC_IER_EOAIE_Pos)   // ?????????? ?? ????????? ?????????
      | (1 << TSC_IER_MCEIE_Pos);      // ?????????? ?? ???????????? ????????

// ?????????? ???????? ??????
TSC->IOHCR &= ~(TSC_IOHCR_G1_IO1_Msk | TSC_IOHCR_G1_IO2_Msk | TSC_IOHCR_G1_IO3_Msk | TSC_IOHCR_G1_IO4_Msk);

// ???????? ????????????
TSC->IOSCR |= (1 << TSC_IOSCR_G1_IO1_Pos);   // PA1
}

